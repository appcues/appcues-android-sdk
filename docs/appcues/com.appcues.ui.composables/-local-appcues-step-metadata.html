<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>LocalAppcuesStepMetadata</title>
    <link href="../../images/logo-icon.svg" rel="icon" type="image/svg">
    <script>var pathToRoot = "../../";</script>
    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script src="https://unpkg.com/kotlin-playground@1"></script><script type="text/javascript" src="../../scripts/sourceset_dependencies.js" async="async"></script>
<link href="../../styles/style.css" rel="Stylesheet">
<link href="../../styles/jetbrains-mono.css" rel="Stylesheet">
<link href="../../styles/main.css" rel="Stylesheet">
<link href="../../styles/prism.css" rel="Stylesheet">
<link href="../../styles/logo-styles.css" rel="Stylesheet">
<script type="text/javascript" src="../../scripts/clipboard.js" async="async"></script>
<script type="text/javascript" src="../../scripts/navigation-loader.js" async="async"></script>
<script type="text/javascript" src="../../scripts/platform-content-handler.js" async="async"></script>
<script type="text/javascript" src="../../scripts/main.js" defer="defer"></script>
<script type="text/javascript" src="../../scripts/prism.js" async="async"></script>
<script type="text/javascript" src="../../scripts/symbol-parameters-wrapper_deferred.js" defer="defer"></script>
</head>
<body>
<div class="navigation-wrapper" id="navigation-wrapper">
    <div id="leftToggler"><span class="icon-toggler"></span></div>
    <div class="library-name">
            <a href="../../index.html">
                    <span>appcues</span>
            </a>
    </div>
    <div>
    </div>
    <div class="pull-right d-flex">
        <div class="filter-section" id="filter-section">
                <button class="platform-tag platform-selector jvm-like" data-active="" data-filter=":appcues:dokkaHtml/release">androidJvm</button>
        </div>
        <button id="theme-toggle-button"><span id="theme-toggle"></span></button>
        <div id="searchBar"></div>
    </div>
</div>
<div id="container">
    <div id="leftColumn">
        <div id="sideMenu"></div>
    </div>
    <div id="main">
<div class="main-content" data-page-type="member" id="content" pageIds="appcues::com.appcues.ui.composables//LocalAppcuesStepMetadata/#/PointingToDeclaration//1172753313">
  <div class="breadcrumbs"><a href="../../index.html">appcues</a><span class="delimiter">/</span><a href="index.html">com.appcues.ui.composables</a><span class="delimiter">/</span><span class="current">LocalAppcuesStepMetadata</span></div>
  <div class="cover ">
    <h1 class="cover"><span>Local</span><wbr></wbr><span>Appcues</span><wbr></wbr><span>Step</span><wbr></wbr><span><span>Metadata</span></span></h1>
  </div>
  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":appcues:dokkaHtml/release"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">val </span><a href="-local-appcues-step-metadata.html">LocalAppcuesStepMetadata</a><span class="token operator">: </span><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProvidableCompositionLocal.html">ProvidableCompositionLocal</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="-appcues-step-metadata/index.html">AppcuesStepMetadata</a><span class="token operator">&gt;</span></div><p class="paragraph">Use LocalAppcuesStepMetadata to access the shared information between steps</p><p class="paragraph">Example usage:</p><h4 class="">Samples</h4><div class="sample-container"><pre><code class="runnablesample monospace block lang-kotlin" theme="idea">import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.State
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import com.appcues.data.model.AppcuesConfigMap
import com.appcues.data.model.getConfig
import com.appcues.trait.BackdropDecoratingTrait
import com.appcues.trait.MetadataSettingTrait
import com.appcues.trait.appcues.BackdropKeyholeTrait.ConfigShape.CIRCLE
import com.appcues.trait.appcues.BackdropKeyholeTrait.ConfigShape.RECTANGLE
import com.appcues.trait.extensions.getRect
import com.appcues.trait.extensions.getRectEncompassesRadius
import com.appcues.trait.extensions.inflateOrEmpty
import com.appcues.trait.extensions.rememberFloatStepAnimation
import com.appcues.trait.extensions.rememberTargetRectangleInfo
import com.appcues.ui.composables.LocalAppcuesStepMetadata
import com.appcues.ui.utils.rememberAppcuesWindowInfo
fun main() { 
   //sampleStart 
   internal class BackdropKeyholeTrait(
    override val config: AppcuesConfigMap,
) : BackdropDecoratingTrait, MetadataSettingTrait {

    companion object {

        const val TYPE = &quot;@appcues/backdrop-keyhole&quot;

        const val METADATA_KEYHOLE_SETTINGS = &quot;keyholeSettings&quot;
    }

    enum class ConfigShape {
        RECTANGLE, CIRCLE
    }

    data class KeyholeSettings(
        val cornerRadius: Double,
        val spreadRadius: Double,
        val blurRadius: Double,
        val shape: ConfigShape,
    )

    private val keyholeSettings = KeyholeSettings(
        cornerRadius = config.getConfig&lt;Double&gt;(&quot;cornerRadius&quot;) ?: 0.0,
        spreadRadius = config.getConfig&lt;Double&gt;(&quot;spreadRadius&quot;) ?: 0.0,
        blurRadius = config.getConfig&lt;Double&gt;(&quot;blurRadius&quot;) ?: 0.0,
        shape = getConfigShape()
    )

    private fun getConfigShape(): ConfigShape {
        return when (config.getConfig&lt;String&gt;(&quot;shape&quot;)) {
            &quot;circle&quot; -&gt; CIRCLE
            &quot;rectangle&quot; -&gt; RECTANGLE
            else -&gt; RECTANGLE
        }
    }

    override fun produceMetadata(): Map&lt;String, Any?&gt; {
        return hashMapOf(METADATA_KEYHOLE_SETTINGS to keyholeSettings)
    }

    @Composable
    override fun BoxScope.BackdropDecorate(content: @Composable BoxScope.() -&gt; Unit) {
        val density = LocalDensity.current
        val metadata = LocalAppcuesStepMetadata.current

        val targetRectInfo = rememberTargetRectangleInfo(metadata)

        val shapeBlurRadius = if (keyholeSettings.shape == CIRCLE) keyholeSettings.blurRadius.toFloat() else 0.0f
        val targetRect = targetRectInfo.getRect(rememberAppcuesWindowInfo()).inflateOrEmpty(keyholeSettings.spreadRadius)
        val floatAnimation = rememberFloatStepAnimation(metadata)
        val encompassesDiameter = targetRect.getRectEncompassesRadius(shapeBlurRadius) * 2

        // animated values
        val xPosition = animateXPositionAsState(targetRect, encompassesDiameter, floatAnimation)
        val yPosition = animateYPositionAsState(targetRect, encompassesDiameter, floatAnimation)
        val width = animateFloatAsState(if (keyholeSettings.shape == RECTANGLE) targetRect.width else encompassesDiameter, floatAnimation)
        val height = animateFloatAsState(if (keyholeSettings.shape == RECTANGLE) targetRect.height else encompassesDiameter, floatAnimation)
        val cornerRadius = animateFloatAsState(targetRect.getCornerRadius(shapeBlurRadius), floatAnimation)
        val blurRadius = animateFloatAsState(shapeBlurRadius, floatAnimation)
        val encompassesRadiusPx = animateFloatAsState(with(density) { encompassesDiameter.dp.toPx() / 2 }, floatAnimation)

        // pixel values
        val sizePx = with(density) { Size(width.value.dp.toPx(), height.value.dp.toPx()) }
        val positionPx = with(density) { Offset(xPosition.value.dp.toPx(), yPosition.value.dp.toPx()) }
        val blurRadiusPx = with(density) { blurRadius.value.dp.toPx() }
        val rectCornerRadius = with(density) { CornerRadius(cornerRadius.value.dp.toPx()) }

        Box(
            modifier = Modifier
                .fillMaxSize()
                // adds a graphic layer to ensure that any BlendModes will work as expected
                .graphicsLayer(alpha = 0.99F)
                .drawWithContent {
                    drawContent()

                    if (encompassesRadiusPx.value &gt; 0) {
                        val shapeCenter = Offset(positionPx.x + sizePx.width / 2, positionPx.y + sizePx.height / 2)
                        val blurStartPoint = ((sizePx.width / 2) - blurRadiusPx) / (sizePx.width / 2)

                        drawRoundRect(
                            topLeft = positionPx,
                            brush = Brush.radialGradient(
                                colorStops = arrayOf(blurStartPoint to Color.Transparent, 1.0f to Color.Black),
                                center = shapeCenter,
                                radius = encompassesRadiusPx.value
                            ),
                            size = sizePx,
                            cornerRadius = rectCornerRadius,
                            blendMode = BlendMode.DstIn
                        )
                    }
                }
        ) {
            content()
        }
    }

    @Composable
    private fun animateXPositionAsState(rect: Rect, encompassesDiameter: Float, animationSpec: AnimationSpec&lt;Float&gt;): State&lt;Float&gt; {
        val circleXOffset = (encompassesDiameter - rect.width) / 2

        return animateFloatAsState(
            targetValue = if (keyholeSettings.shape == RECTANGLE) rect.left else rect.left - circleXOffset,
            animationSpec = animationSpec
        )
    }

    @Composable
    private fun animateYPositionAsState(rect: Rect, encompassesDiameter: Float, animationSpec: AnimationSpec&lt;Float&gt;): State&lt;Float&gt; {
        val circleYOffset = (encompassesDiameter - rect.height) / 2

        return animateFloatAsState(
            targetValue = if (keyholeSettings.shape == RECTANGLE) rect.top else rect.top - circleYOffset,
            animationSpec = animationSpec
        )
    }

    private fun Rect.getCornerRadius(blurRadius: Float): Float {
        return when (keyholeSettings.shape) {
            RECTANGLE -&gt; keyholeSettings.cornerRadius.toFloat()
            CIRCLE -&gt; (getRectEncompassesRadius(blurRadius))
                // calculate Radius that encompasses the rect
                .let { ((it * Math.PI) / 2).toFloat() }
        }
    }
} 
   //sampleEnd
}</code></pre></div></div></div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2023 Copyright</span><span
                class="pull-right"><span>Generated by </span><a
                href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
    </div>
</div>
</body>
</html>
